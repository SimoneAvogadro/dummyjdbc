package com.googlecode.dummyjdbc.statement.impl;

import java.io.File;
import java.math.BigDecimal;
import java.sql.Date;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.googlecode.dummyjdbc.statement.PreparedStatementAdapter;

/**
 * Wraps the {@link CsvStatement} as a prepared statement.
 *
 * @author Kai Winter
 */
public class CsvPreparedStatement extends PreparedStatementAdapter {

	private static final Pattern INSERT_INTO_PATTERN = Pattern.compile("(?:--[^\\n]*)?\\s*insert\\s*into\\s*([a-zA-Z]*)\\s*\\(.*", Pattern.CASE_INSENSITIVE|Pattern.MULTILINE);

	private static final Pattern UPDATE_TABLE_PATTERN = Pattern.compile("(?:--[^\\\\n]*)?\\s*update\\s*([a-zA-Z]*)\\s*", Pattern.CASE_INSENSITIVE|Pattern.MULTILINE);

	static final int MAX_PARAMS = 500;
	
	/**
	 * Params received during the insert/update operation
	 */
	Object[] params = new Object[MAX_PARAMS];
	
    /**
     * Target table for insert/update operations
     */
    private String targetTable4Updates = null;
    
	private final CsvStatement statement;
	private final String sql;

	private ResultSet currentResultSet;

	/**
	 * Constructs a new {@link CsvPreparedStatement}.
	 *
	 * @param tableResources {@link Map} of table name to CSV file.
	 * @param sql
	 *            the SQL statement.
	 */
	public CsvPreparedStatement(Map<String, File> tableResources, String sql) {
		this.statement = new CsvStatement(tableResources);
		this.sql = sql;
	}

	
	/**
	 * Always reply that 1 row was affected (most common case) if we can identify the target table name
	 * otherwise return 0
	 */
	@Override
	public int executeUpdate(String sql) throws SQLException {

		// Try to check for a special heading comment within SQL
		Matcher commentMatcher = CsvStatement.COMMENT_HEADLINE_PATTERN.matcher(sql);
		if (commentMatcher.matches()) {
			targetTable4Updates = commentMatcher.group(1);
			InMemoryCSV.register( targetTable4Updates, buildParamsString() );
			return 1;
		}
		
		// Try to interpret SQL as a SELECT on a table
		Matcher insertMatcher = INSERT_INTO_PATTERN.matcher(sql);
		if (insertMatcher.matches()) {
			targetTable4Updates = insertMatcher.group(1);
			InMemoryCSV.register( targetTable4Updates, buildParamsString() );
			return 1;
		}

		// Try to interpret SQL as call of a stored procedure
		Matcher updateMatcher = UPDATE_TABLE_PATTERN.matcher(sql);
		if (updateMatcher.matches()) {
			targetTable4Updates = updateMatcher.group(1);
			InMemoryCSV.register( targetTable4Updates, buildParamsString() );
			return 1;
		}

		return 0;
	}

	/**
	 * build a string representing the objects which have been received
	 * @return
	 */
	private String buildParamsString() {
		// 1: build the string (space separated)
		StringBuilder s = new StringBuilder();
		for (int i = 0; i < params.length; i++) {
			s.append(params[i]).append(' ');
		}
		
		// 2: trim and add commas between parameters
		String res = s.toString().trim();
		res = res.replace(' ', ',');
		
		return res;
	}
	
	@Override
	public void setObject(int parameterIndex, Object x) throws SQLException {
		params[parameterIndex]=x;
	}

	@Override
	public void setString(int parameterIndex, String x) throws SQLException {
		params[parameterIndex]=x;
	}
	
	@Override
	public void setInt(int parameterIndex, int x) throws SQLException {
		params[parameterIndex]=x;
	}

	@Override
	public void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException {
		params[parameterIndex]=x;
	}
	
	@Override
	public void setDouble(int parameterIndex, double x) throws SQLException {
		params[parameterIndex]=x;
	}
	
	@Override
	public void setTime(int parameterIndex, Time x) throws SQLException {
		params[parameterIndex]=x;
	}
	
	@Override
	public void setTimestamp(int parameterIndex, Timestamp x) throws SQLException {
		params[parameterIndex]=x;
	}
	
	@Override
	public void setDate(int parameterIndex, Date x) throws SQLException {
		params[parameterIndex]=x;
	}
	
	@Override
	public int executeUpdate() throws SQLException {
		return executeUpdate(sql);
	}
	
	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
		return executeUpdate(sql);
	}
	
	@Override
	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
		return executeUpdate(sql);
	}
	
	@Override
	public int executeUpdate(String sql, String[] columnNames) throws SQLException {
		return executeUpdate(sql);
	}
	
	
	@Override
	public ResultSet executeQuery() throws SQLException {
		return (currentResultSet = statement.executeQuery(sql));
	}

	@Override
	public ResultSet executeQuery(String sql) throws SQLException {
		return (currentResultSet = statement.executeQuery(sql));
	}

	@Override
	public boolean execute() throws SQLException {
		// try to generate output row
		currentResultSet = statement.executeQuery(sql);
		// try up update (generate params)
		executeUpdate(sql);
		return true;
	}

	@Override
	public boolean execute(String sql) throws SQLException {
		currentResultSet = statement.executeQuery(sql);
		return true;
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		return execute(sql);
	}

	@Override
	public boolean execute(String sql, String[] columnNames) throws SQLException {
		return execute(sql);
	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
		return execute(sql);
	}

	@Override
	public ResultSet getResultSet() throws SQLException {
		return currentResultSet;
	}
}
